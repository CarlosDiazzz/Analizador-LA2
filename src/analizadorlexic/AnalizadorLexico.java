/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JFrame.java to edit this template
 */
package analizadorlexic;

import com.formdev.flatlaf.FlatLaf;
import com.formdev.flatlaf.themes.FlatMacLightLaf;
import java.awt.Color;
import java.awt.Font;
import java.awt.GraphicsEnvironment;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.regex.Pattern;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.JTextArea;
import javax.swing.UIManager;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import javax.swing.filechooser.FileNameExtensionFilter;
import javax.swing.text.BadLocationException;
import javax.swing.text.DefaultHighlighter;
import javax.swing.text.Highlighter;

/**
 *
 * @author carlo
 */
public class AnalizadorLexico extends javax.swing.JFrame {

    private List<Simbolo> tablaSimbolos = new ArrayList<>();

    /**
     * Creates new form AnalizadorLexico
     */
    public AnalizadorLexico() {
        try {
            InputStream is = getClass().getResourceAsStream("/fuentes/Manrope-Regular.ttf");
            if (is == null) {
                throw new IOException("No se encontr√≥ el archivo de fuente Manrope");
            }

            Font manrope = Font.createFont(Font.TRUETYPE_FONT, is).deriveFont(14f);
            GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();
            ge.registerFont(manrope);

            UIManager.put("defaultFont", manrope);
            FlatLaf.registerCustomDefaultsSource("mytheme");
            FlatMacLightLaf.setup();
            UIManager.setLookAndFeel(new FlatMacLightLaf());

        } catch (Exception e) {
            System.out.println("Error al aplicar el tema: " + e);
        }

        initComponents();

        lineasArea.setEditable(false);
        txtSalida.setEditable(false);

        txtEntrada.getDocument().addDocumentListener(new DocumentListener() {
            public void insertUpdate(DocumentEvent e) {
                actualizarLineas();
            }

            public void removeUpdate(DocumentEvent e) {
                actualizarLineas();
            }

            public void changedUpdate(DocumentEvent e) {
                actualizarLineas();
            }
        });
        this.setLocationRelativeTo(null);
    }

    private void actualizarLineas() {
        String texto = txtEntrada.getText();
        int lineas = texto.split("\n", -1).length;
        StringBuilder sb = new StringBuilder();
        for (int i = 1; i <= lineas; i++) {
            sb.append(i).append("\n");
        }
        lineasArea.setText(sb.toString());
    }

    /**
     * This method is called from within the constructor to initialize the form. WARNING: Do NOT modify this code. The content of this method is always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();
        txtEntrada = new javax.swing.JTextArea();
        jScrollPane2 = new javax.swing.JScrollPane();
        txtSalida = new javax.swing.JTextArea();
        jPanel1 = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        btnAnalizar = new javax.swing.JButton();
        limpiarButto = new javax.swing.JButton();
        cargarArchivoButtom = new javax.swing.JButton();
        guardarArchivoButton = new javax.swing.JButton();
        jScrollPane3 = new javax.swing.JScrollPane();
        lineasArea = new javax.swing.JTextArea();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Analizador Lexico");
        setAutoRequestFocus(false);
        setBackground(new java.awt.Color(255, 255, 255));
        setExtendedState(6);
        setIconImages(null);

        txtEntrada.setColumns(20);
        txtEntrada.setRows(5);
        jScrollPane1.setViewportView(txtEntrada);

        txtSalida.setColumns(20);
        txtSalida.setRows(5);
        jScrollPane2.setViewportView(txtSalida);

        jLabel1.setFont(new java.awt.Font("Segoe UI Semibold", 1, 36)); // NOI18N
        jLabel1.setText("Analizador");

        btnAnalizar.setText("Analizar");
        btnAnalizar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnAnalizarActionPerformed(evt);
            }
        });

        limpiarButto.setText("Limpiar");
        limpiarButto.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                limpiarButtoActionPerformed(evt);
            }
        });

        cargarArchivoButtom.setText("Cargar Archivo");
        cargarArchivoButtom.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cargarArchivoButtomActionPerformed(evt);
            }
        });

        guardarArchivoButton.setText("Guardar Archivo");
        guardarArchivoButton.setEnabled(false);
        guardarArchivoButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                guardarArchivoButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel1)
                .addGap(209, 209, 209)
                .addComponent(cargarArchivoButtom)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(guardarArchivoButton)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 143, Short.MAX_VALUE)
                .addComponent(btnAnalizar, javax.swing.GroupLayout.PREFERRED_SIZE, 123, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(limpiarButto, javax.swing.GroupLayout.PREFERRED_SIZE, 107, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(btnAnalizar)
                    .addComponent(limpiarButto)
                    .addComponent(cargarArchivoButtom)
                    .addComponent(guardarArchivoButton))
                .addContainerGap())
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel1)
                .addContainerGap(23, Short.MAX_VALUE))
        );

        lineasArea.setColumns(20);
        lineasArea.setRows(5);
        lineasArea.setCaretColor(new java.awt.Color(140, 140, 140));
        jScrollPane3.setViewportView(lineasArea);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 47, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 448, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane2))
            .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 535, Short.MAX_VALUE)
                    .addComponent(jScrollPane2)
                    .addComponent(jScrollPane3))
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void btnAnalizarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnAnalizarActionPerformed
        analizar(txtEntrada.getText());
        guardarArchivoButton.setEnabled(false);
        guardarArchivoButton.setEnabled(false);
    }//GEN-LAST:event_btnAnalizarActionPerformed

    private void limpiarButtoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_limpiarButtoActionPerformed
        txtEntrada.setText("");
        txtSalida.setText("");
        lineasArea.setText("");
        txtEntrada.getHighlighter().removeAllHighlights();
        guardarArchivoButton.setEnabled(false);
        limpiarButto.setEnabled(false);
    }//GEN-LAST:event_limpiarButtoActionPerformed

    private void cargarArchivoButtomActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cargarArchivoButtomActionPerformed
        guardarArchivoButton.setEnabled(true);
        JFileChooser chooser = new JFileChooser();

        // Filtro: solo archivos de texto (.txt, .java, .c, .cpp, .py, etc.)
        FileNameExtensionFilter filtro = new FileNameExtensionFilter(
                "Archivos de texto", "txt", "java", "c", "cpp", "py", "html", "xml", "json", "js", "css"
        );
        chooser.setFileFilter(filtro);

        int resultado = chooser.showOpenDialog(this);
        if (resultado == JFileChooser.APPROVE_OPTION) {
            File archivo = chooser.getSelectedFile();
            try (BufferedReader reader = new BufferedReader(new FileReader(archivo))) {
                StringBuilder sb = new StringBuilder();
                String linea;
                while ((linea = reader.readLine()) != null) {
                    sb.append(linea).append("\n");
                }
                txtEntrada.setText(sb.toString());
            } catch (IOException e) {
                JOptionPane.showMessageDialog(this, "Error al leer el archivo.");
            }
        }
    }//GEN-LAST:event_cargarArchivoButtomActionPerformed

    private void guardarArchivoButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_guardarArchivoButtonActionPerformed
        JFileChooser chooser = new JFileChooser();
        int resultado = chooser.showSaveDialog(this);
        if (resultado == JFileChooser.APPROVE_OPTION) {
            File archivo = chooser.getSelectedFile();
            try (BufferedWriter writer = new BufferedWriter(new FileWriter(archivo))) {
                writer.write(txtEntrada.getText());
                JOptionPane.showMessageDialog(this, "Archivo guardado correctamente.");
            } catch (IOException e) {
                JOptionPane.showMessageDialog(this, "Error al guardar el archivo");
            }
        }
    }//GEN-LAST:event_guardarArchivoButtonActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        try {
            UIManager.setLookAndFeel(new FlatMacLightLaf());
        } catch (Exception e) {
            e.printStackTrace();
        }
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;

                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(AnalizadorLexico.class
                    .getName()).log(java.util.logging.Level.SEVERE, null, ex);

        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(AnalizadorLexico.class
                    .getName()).log(java.util.logging.Level.SEVERE, null, ex);

        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(AnalizadorLexico.class
                    .getName()).log(java.util.logging.Level.SEVERE, null, ex);

        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(AnalizadorLexico.class
                    .getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new AnalizadorLexico().setVisible(true);
            }
        });
    }

    private void analizar(String entrada) {

        List<Token> tokens = new ArrayList<>();
        tablaSimbolos.clear();
        txtSalida.setText("");
        txtEntrada.getHighlighter().removeAllHighlights();

        Pattern patronID = Pattern.compile("^[A-Z]+[0-9]*$", Pattern.CASE_INSENSITIVE);
        Pattern patronValor = Pattern.compile("^\\d+$");
        Set<String> comandos = Set.of("base", "codo", "hombro", "garra", "velocidad", "repetir");

        boolean huboError = false;
        String[] palabras = entrada.split("\\s+");
        String robotID = null;

        int i = 0;
        while (i < palabras.length) {
            String actual = palabras[i];

            try {
                if (actual.equalsIgnoreCase("Robot")) {
                    if (i + 1 < palabras.length && patronID.matcher(palabras[i + 1]).matches()) {
                        robotID = palabras[i + 1];

                        final String robotIDCopia = robotID;
                        boolean yaExiste = tablaSimbolos.stream()
                                .anyMatch(s -> s.getId().equalsIgnoreCase(robotIDCopia) && s.getMetodo().equals("robot"));

                        if (yaExiste) {
                            lanzarErrorLinea("Robot ya fue declarado anteriormente: " + robotID, robotID);
                            huboError = true;
                            i += 2;
                            continue;
                        }

                        tokens.add(new Token("PALABRA_RESERVADA", "Robot"));
                        tokens.add(new Token("IDENTIFICADOR", robotID));
                        tablaSimbolos.add(new Simbolo(robotID, "robot", 0, 0));
                        i += 2;
                    } else {
                        lanzarErrorLinea("Declaraci√≥n de Robot inv√°lida: falta identificador", actual);
                        tokens.add(new Token("ERROR", actual));
                        huboError = true;
                        i++;
                    }
                    continue;
                }

                if (i + 2 < palabras.length) {
                    String full = palabras[i];
                    String[] partes = full.split("\\.");

                    if (partes.length != 2) {
                        lanzarErrorLinea("Sintaxis inv√°lida, se esperaba ID.comando", full);
                        tokens.add(new Token("ERROR", full));
                        huboError = true;
                        i++;
                        continue;
                    }

                    String id = partes[0];
                    String comb = partes[1];

                    boolean robotDeclarado = tablaSimbolos.stream()
                            .anyMatch(s -> s.getId().equalsIgnoreCase(id) && s.getMetodo().equals("robot"));

                    if (!robotDeclarado) {
                        lanzarErrorLinea("Robot no ha sido declarado: " + id, full);
                        tokens.add(new Token("ERROR", id));
                        huboError = true;
                        i++;
                        continue;
                    }

                    if (!comandos.contains(comb.toLowerCase())) {
                        lanzarErrorLinea("Comando inv√°lido: " + comb, comb);
                        tokens.add(new Token("ERROR", comb));
                        huboError = true;
                        i++;
                        continue;
                    }

                    String operador = palabras[i + 1];
                    String valor = palabras[i + 2];

                    if (!operador.equals("=")) {
                        lanzarErrorLinea("Falta operador '='", operador);
                        tokens.add(new Token("ERROR", operador));
                        huboError = true;
                        i++;
                        continue;
                    }

                    // Manejo especial para repetir
                    if (comb.equalsIgnoreCase("repetir")) {
                        if (!valor.matches("\\d+")) {
                            lanzarErrorLinea("Repeticiones inv√°lidas: se esperaba un n√∫mero", valor);
                            tokens.add(new Token("ERROR", valor));
                            huboError = true;
                            i++;
                            continue;
                        }

                        int repeticiones = Integer.parseInt(valor);
                        if (repeticiones < 1 || repeticiones > 100) {
                            lanzarErrorLinea("Repeticiones fuera de rango (1 a 100): " + repeticiones, valor);
                            tokens.add(new Token("ERROR", valor));
                            huboError = true;
                            i++;
                            continue;
                        }

                        int j = i + 3;
                        List<String> bloque = new ArrayList<>();

                        if (j >= palabras.length || !palabras[j].equals("{")) {
                            lanzarErrorLinea("Falta '{' para abrir el bloque de repetici√≥n", palabras[j]);
                            tokens.add(new Token("ERROR", palabras[j]));
                            huboError = true;
                            i++;
                            continue;
                        }

                        j++;
                        while (j < palabras.length && !palabras[j].equals("}")) {
                            bloque.add(palabras[j]);
                            j++;
                        }

                        if (j >= palabras.length || !palabras[j].equals("}")) {
                            lanzarErrorLinea("Falta '}' para cerrar el bloque de repetici√≥n", valor);
                            tokens.add(new Token("ERROR", valor));
                            huboError = true;
                            break;
                        }

                        String bloqueTexto = String.join(" ", bloque);
                        for (int r = 0; r < repeticiones; r++) {
                            analizarBloque(bloqueTexto, tokens);
                        }

                        tokens.add(new Token("IDENTIFICADOR", id));
                        tokens.add(new Token("OPERADOR", "."));
                        tokens.add(new Token("COMANDO", "repetir"));
                        tokens.add(new Token("OPERADOR", "="));
                        tokens.add(new Token("NUMERO", String.valueOf(repeticiones)));

                        i = j + 1;
                        continue;
                    }

                    if (!patronValor.matcher(valor).matches()) {
                        lanzarErrorLinea("Valor num√©rico inv√°lido: " + valor, valor);
                        tokens.add(new Token("ERROR", valor));
                        huboError = true;
                        i++;
                        continue;
                    }

                    int valorNumerico = Integer.parseInt(valor);
                    boolean valorValido = switch (comb.toLowerCase()) {
                        case "base" ->
                            valorNumerico >= 0 && valorNumerico <= 360;
                        case "hombro", "codo" ->
                            valorNumerico >= 0 && valorNumerico <= 180;
                        case "garra" ->
                            valorNumerico >= 0 && valorNumerico <= 90;
                        case "velocidad" ->
                            valorNumerico >= 1 && valorNumerico <= 60;
                        default ->
                            false;
                    };

                    if (!valorValido) {
                        lanzarErrorLinea("Valor fuera de rango para " + comb + ": " + valor, valor);
                        tokens.add(new Token("ERROR", valor));
                        huboError = true;
                        i += 3;
                        continue;
                    }

                    boolean yaAsignado = tablaSimbolos.stream()
                            .anyMatch(s -> s.getId().equalsIgnoreCase(id) && s.getMetodo().equalsIgnoreCase(comb));

                    if (yaAsignado) {
                        tablaSimbolos.removeIf(s -> s.getId().equalsIgnoreCase(id) && s.getMetodo().equalsIgnoreCase(comb));
                    }

                    tokens.add(new Token("IDENTIFICADOR", id));
                    tokens.add(new Token("OPERADOR", "."));
                    tokens.add(new Token("COMANDO", comb));
                    tokens.add(new Token("OPERADOR", "="));
                    tokens.add(new Token("NUMERO", valor));

                    tablaSimbolos.add(new Simbolo(id, comb, 1, valorNumerico));
                    i += 3;
                } else {
                    StringBuilder restante = new StringBuilder();
                    for (int j = i; j < palabras.length; j++) {
                        restante.append(palabras[j]).append(" ");
                    }
                    String errorContenido = restante.toString().trim();
                    lanzarErrorLinea("Expresi√≥n incompleta: se esperaban ID.comando = valor", errorContenido);
                    pintarPrimeraLineaCon(errorContenido);
                    tokens.add(new Token("ERROR", errorContenido));
                    break;
                }
            } catch (Exception e) {
                lanzarErrorLinea("Error inesperado: " + e.getMessage(), actual);
                tokens.add(new Token("ERROR", "Excepci√≥n"));
                huboError = true;
                i++;
            }
        }

        for (Token t : tokens) {
            if (!t.getTipo().equals("ERROR")) {
                txtSalida.append("[" + t.getTipo() + "] ‚Üí " + t.getValor() + "\n");
            }
        }

        if (!huboError) {
            txtSalida.append("‚úÖ An√°lisis correcto. ¬°OK!\n");
            txtSalida.append("\nüîß Tabla de s√≠mbolos:\n");
            txtSalida.append(String.format("%-5s %-10s %-10s %-10s\n", "ID", "M√âTODO", "PAR√ÅMETRO", "VALOR"));
            for (Simbolo s : tablaSimbolos) {
                txtSalida.append(s.toString() + "\n");
            }
        }
    }

    private void pintarLineaRoja(JTextArea area, int numeroLinea) {
        try {
            int start = area.getLineStartOffset(numeroLinea);
            int end = area.getLineEndOffset(numeroLinea);
            Highlighter highlighter = area.getHighlighter();
            Highlighter.HighlightPainter painter = new DefaultHighlighter.DefaultHighlightPainter(Color.PINK);
            highlighter.addHighlight(start, end, painter);
        } catch (BadLocationException e) {
            e.printStackTrace();
        }
    }

    private void pintarPrimeraLineaCon(String contenido) {
        try {
            String texto = txtEntrada.getText();
            int index = texto.indexOf(contenido);
            if (index >= 0) {
                int linea = txtEntrada.getLineOfOffset(index);
                pintarLineaRoja(txtEntrada, linea);
            }
        } catch (BadLocationException e) {
            e.printStackTrace();
        }
    }

    private void lanzarErrorLinea(String mensaje, String contenido) {
        txtSalida.append("‚ùå Error: " + mensaje + " ‚Üí \"" + contenido + "\"\n");

        try {
            String texto = txtEntrada.getText();
            int index = texto.indexOf(contenido);
            if (index >= 0) {
                int linea = txtEntrada.getLineOfOffset(index);
                pintarLineaRoja(txtEntrada, linea);

                // A√±ade el n√∫mero de l√≠nea al mensaje:
                txtSalida.append("üî¥ L√≠nea: " + (linea + 1) + "\n");
            }
        } catch (BadLocationException e) {
            e.printStackTrace();
        }
    }

    private void analizarBloque(String entrada, List<Token> tokens) {
        String[] palabras = entrada.split("\\s+");
        Pattern patronID = Pattern.compile("^[A-Z]+[0-9]*$", Pattern.CASE_INSENSITIVE);
        Pattern patronValor = Pattern.compile("^\\d+$");
        Set<String> comandos = Set.of("base", "codo", "hombro", "garra", "velocidad");

        int i = 0;
        while (i < palabras.length) {
            String full = palabras[i];
            if (i + 2 >= palabras.length) {
                break;
            }

            String[] partes = full.split("\\.");
            if (partes.length != 2) {
                break;
            }

            String id = partes[0];
            String comb = partes[1];
            String operador = palabras[i + 1];
            String valor = palabras[i + 2];

            if (!operador.equals("=") || !patronValor.matcher(valor).matches()) {
                break;
            }

            int valorNumerico = Integer.parseInt(valor);

            if (!tablaSimbolos.stream().anyMatch(s -> s.getId().equalsIgnoreCase(id) && s.getMetodo().equals("robot"))) {
                lanzarErrorLinea("Robot no ha sido declarado: " + id, full);
                tokens.add(new Token("ERROR", full));
                i += 3;
                continue;
            }

            if (!comandos.contains(comb.toLowerCase())) {
                lanzarErrorLinea("Comando inv√°lido: " + comb, comb);
                tokens.add(new Token("ERROR", comb));
                i += 3;
                continue;
            }

            if (comb.equalsIgnoreCase("velocidad")) {
                if (valorNumerico < 0 || valorNumerico > 10) {
                    lanzarErrorLinea("Velocidad fuera de rango (0-10 segundos): " + valor, valor);
                    tokens.add(new Token("ERROR", valor));
                    i += 3;
                    continue;
                }

                tablaSimbolos.removeIf(s -> s.getId().equalsIgnoreCase(id) && s.getMetodo().equalsIgnoreCase("velocidad"));
                tablaSimbolos.add(new Simbolo(id, "velocidad", 1, valorNumerico));
            } else {
                boolean valorValido = switch (comb.toLowerCase()) {
                    case "base" ->
                        valorNumerico >= 0 && valorNumerico <= 360;
                    case "hombro", "codo" ->
                        valorNumerico >= 0 && valorNumerico <= 180;
                    case "garra" ->
                        valorNumerico >= 0 && valorNumerico <= 90;
                    default ->
                        false;
                };

                if (!valorValido) {
                    lanzarErrorLinea("Valor fuera de rango para " + comb + ": " + valor, valor);
                    tokens.add(new Token("ERROR", valor));
                    i += 3;
                    continue;
                }

                tablaSimbolos.removeIf(s -> s.getId().equalsIgnoreCase(id) && s.getMetodo().equalsIgnoreCase(comb));
                tablaSimbolos.add(new Simbolo(id, comb, 1, valorNumerico));
            }

            tokens.add(new Token("IDENTIFICADOR", id));
            tokens.add(new Token("OPERADOR", "."));
            tokens.add(new Token("COMANDO", comb));
            tokens.add(new Token("OPERADOR", "="));
            tokens.add(new Token("NUMERO", valor));

            // Aplicar pausa si hay velocidad
            Optional<Simbolo> velocidad = tablaSimbolos.stream()
                    .filter(s -> s.getId().equalsIgnoreCase(id) && s.getMetodo().equalsIgnoreCase("velocidad"))
                    .findFirst();

            if (velocidad.isPresent()) {
                int ms = velocidad.get().getValor() * 1000;
                try {
                    Thread.sleep(ms);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }

            i += 3;
        }
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btnAnalizar;
    private javax.swing.JButton cargarArchivoButtom;
    private javax.swing.JButton guardarArchivoButton;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JButton limpiarButto;
    private javax.swing.JTextArea lineasArea;
    private javax.swing.JTextArea txtEntrada;
    private javax.swing.JTextArea txtSalida;
    // End of variables declaration//GEN-END:variables
}
